# AWS API Gateway ÂÆåÂÖ®„Ç¨„Ç§„Éâ

## ÁõÆÊ¨°
- [API Gateway„Å®„ÅØ](#api-gateway„Å®„ÅØ)
- [REST API vs HTTP API](#rest-api-vs-http-api)
- [HTTP API](#http-api)
- [REST API](#rest-api)
- [Ë™çË®º„ÉªË™çÂèØ](#Ë™çË®ºË™çÂèØ)
- [CORSË®≠ÂÆö](#corsË®≠ÂÆö)
- [„É™„ÇØ„Ç®„Çπ„Éà/„É¨„Çπ„Éù„É≥„ÇπÂ§âÊèõ](#„É™„ÇØ„Ç®„Çπ„Éà„É¨„Çπ„Éù„É≥„ÇπÂ§âÊèõ)
- [„É¨„Éº„ÉàÂà∂Èôê„Å®„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞](#„É¨„Éº„ÉàÂà∂Èôê„Å®„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞)
- [„Ç´„Çπ„Çø„É†„Éâ„É°„Ç§„É≥](#„Ç´„Çπ„Çø„É†„Éâ„É°„Ç§„É≥)
- [WebSocket API](#websocket-api)
- [„É¢„Éã„Çø„É™„É≥„Ç∞](#„É¢„Éã„Çø„É™„É≥„Ç∞)
- [„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ](#„Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ)

---

## API Gateway„Å®„ÅØ

AWS „ÅÆ„Éï„É´„Éû„Éç„Éº„Ç∏„Éâ API ÁÆ°ÁêÜ„Çµ„Éº„Éì„Çπ„ÄÇRESTful API„ÄÅHTTP API„ÄÅWebSocket API „ÇíÊßãÁØâ„ÉªÂÖ¨Èñã„Åß„Åç„Çã„ÄÇ

### ÁâπÂæ¥

- üåê ÂÆåÂÖ®„Éû„Éç„Éº„Ç∏„Éâ: „Çµ„Éº„Éê„ÉºÁÆ°ÁêÜ‰∏çË¶Å
- üìà Ëá™Âãï„Çπ„Ç±„Éº„É´: „Éà„É©„Éï„Ç£„ÉÉ„ÇØ„Å´Âøú„Åò„Å¶Ëá™Âãï„Çπ„Ç±„Éº„É´
- üîí „Çª„Ç≠„É•„É™„ÉÜ„Ç£: Ë™çË®º„ÉªË™çÂèØ„ÄÅDDoS‰øùË≠∑
- üí∞ ÂæìÈáèË™≤Èáë: „É™„ÇØ„Ç®„Çπ„ÉàÊï∞„Å´Âøú„Åò„ÅüË™≤Èáë
- üîÑ Áµ±Âêà: Lambda, EC2, Â§ñÈÉ®API„Å®Áµ±Âêà

### „É¶„Éº„Çπ„Ç±„Éº„Çπ

```
‚úì „Çµ„Éº„Éê„Éº„É¨„ÇπAPI
‚úì „Éû„Ç§„ÇØ„É≠„Çµ„Éº„Éì„Çπ„ÅÆ„Ç≤„Éº„Éà„Ç¶„Çß„Ç§
‚úì „É¨„Ç¨„Ç∑„Éº„Ç∑„Çπ„ÉÜ„É†„ÅÆAPIÂåñ
‚úì WebSocket„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
‚úì „É¢„Éê„Ç§„É´/Web„Ç¢„Éó„É™„ÅÆ„Éê„ÉÉ„ÇØ„Ç®„É≥„Éâ
```

---

## REST API vs HTTP API

### ÊØîËºÉË°®

| Ê©üËÉΩ | HTTP API | REST API |
|-----|---------|----------|
| ÊñôÈáë | ÂÆâ„ÅÑ | È´ò„ÅÑ |
| „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ | È´òÈÄü | Ê®ôÊ∫ñ |
| „É™„ÇØ„Ç®„Çπ„ÉàÂ§âÊèõ | ÈôêÂÆöÁöÑ | È´òÊ©üËÉΩ |
| API Keys | ‚ùå | ‚úì |
| Usage Plans | ‚ùå | ‚úì |
| WAFÁµ±Âêà | ‚ùå | ‚úì |
| JWTË™çË®º | ‚úì | „Ç´„Çπ„Çø„É†ÂÆüË£Ö |
| CognitoÁµ±Âêà | ‚úì | ‚úì |
| LambdaÁµ±Âêà | ‚úì | ‚úì |

### ÈÅ∏ÊäûÂü∫Ê∫ñ

```
HTTP API „ÇíÈÅ∏„Å∂Â†¥Âêà:
‚úì „Ç≥„Çπ„ÉàÈáçË¶ñ
‚úì „Ç∑„É≥„Éó„É´„Å™API
‚úì JWTË™çË®º„ÅÆ„Åø
‚úì È´ò„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπË¶ÅÊ±Ç

REST API „ÇíÈÅ∏„Å∂Â†¥Âêà:
‚úì È´òÂ∫¶„Å™„É™„ÇØ„Ç®„Çπ„ÉàÂ§âÊèõ
‚úì API Keys / Usage Plans
‚úì WAFÁµ±Âêà
‚úì „É¨„Ç¨„Ç∑„Éº„Ç∑„Çπ„ÉÜ„É†Áµ±Âêà
```

---

## HTTP API

### Serverless Framework „Åß‰ΩúÊàê

```yaml
# serverless.yml
service: my-http-api

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-1

functions:
  getUsers:
    handler: src/functions/users/list.handler
    events:
      - httpApi:
          path: /users
          method: get

  getUser:
    handler: src/functions/users/get.handler
    events:
      - httpApi:
          path: /users/{id}
          method: get

  createUser:
    handler: src/functions/users/create.handler
    events:
      - httpApi:
          path: /users
          method: post

  updateUser:
    handler: src/functions/users/update.handler
    events:
      - httpApi:
          path: /users/{id}
          method: put

  deleteUser:
    handler: src/functions/users/delete.handler
    events:
      - httpApi:
          path: /users/{id}
          method: delete
```

### Lambda Èñ¢Êï∞ÂÆüË£Ö

```typescript
// src/functions/users/list.ts
import { APIGatewayProxyHandlerV2 } from 'aws-lambda'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, ScanCommand } from '@aws-sdk/lib-dynamodb'

const client = DynamoDBDocumentClient.from(new DynamoDBClient({}))
const TABLE_NAME = process.env.TABLE_NAME!

export const handler: APIGatewayProxyHandlerV2 = async (event) => {
  try {
    const result = await client.send(new ScanCommand({
      TableName: TABLE_NAME
    }))

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        users: result.Items
      })
    }
  } catch (error) {
    console.error('Error:', error)
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    }
  }
}
```

```typescript
// src/functions/users/get.ts
import { APIGatewayProxyHandlerV2 } from 'aws-lambda'
import { DynamoDBDocumentClient, GetCommand } from '@aws-sdk/lib-dynamodb'

export const handler: APIGatewayProxyHandlerV2 = async (event) => {
  const userId = event.pathParameters?.id

  if (!userId) {
    return {
      statusCode: 400,
      body: JSON.stringify({ error: 'User ID is required' })
    }
  }

  try {
    const result = await client.send(new GetCommand({
      TableName: TABLE_NAME,
      Key: {
        PK: `USER#${userId}`,
        SK: 'PROFILE'
      }
    }))

    if (!result.Item) {
      return {
        statusCode: 404,
        body: JSON.stringify({ error: 'User not found' })
      }
    }

    return {
      statusCode: 200,
      body: JSON.stringify(result.Item)
    }
  } catch (error) {
    console.error('Error:', error)
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'Internal server error' })
    }
  }
}
```

### CORSË®≠ÂÆö

```yaml
# serverless.yml
provider:
  httpApi:
    cors:
      allowedOrigins:
        - https://example.com
        - https://app.example.com
      allowedHeaders:
        - Content-Type
        - Authorization
      allowedMethods:
        - GET
        - POST
        - PUT
        - DELETE
      allowCredentials: true
      maxAge: 6000
```

---

## REST API

### Serverless Framework „Åß‰ΩúÊàê

```yaml
# serverless.yml
service: my-rest-api

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-1

  apiGateway:
    restApiId: ${ssm:/myapp/api-gateway-id}  # Êó¢Â≠òAPI„Çí‰ΩøÁî®
    restApiRootResourceId: ${ssm:/myapp/api-gateway-root-id}

functions:
  getUsers:
    handler: src/functions/users/list.handler
    events:
      - http:
          path: users
          method: get
          cors: true

  createUser:
    handler: src/functions/users/create.handler
    events:
      - http:
          path: users
          method: post
          cors: true
          # „É™„ÇØ„Ç®„Çπ„Éà„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
          request:
            schemas:
              application/json: ${file(schemas/user-create.json)}
```

### „É™„ÇØ„Ç®„Çπ„Éà„Éê„É™„Éá„Éº„Ç∑„Éß„É≥

```json
// schemas/user-create.json
{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "title": "User Create Schema",
  "type": "object",
  "properties": {
    "email": {
      "type": "string",
      "format": "email"
    },
    "name": {
      "type": "string",
      "minLength": 2,
      "maxLength": 100
    }
  },
  "required": ["email", "name"]
}
```

### API Keys & Usage Plans

```yaml
# serverless.yml
provider:
  apiGateway:
    apiKeys:
      - name: free-tier
        value: ${env:FREE_TIER_API_KEY}
      - name: premium-tier
        value: ${env:PREMIUM_TIER_API_KEY}

    usagePlan:
      - free:
          quota:
            limit: 1000
            period: MONTH
          throttle:
            rateLimit: 10
            burstLimit: 20
      - premium:
          quota:
            limit: 10000
            period: MONTH
          throttle:
            rateLimit: 100
            burstLimit: 200

functions:
  publicApi:
    handler: handler.public
    events:
      - http:
          path: public
          method: get

  privateApi:
    handler: handler.private
    events:
      - http:
          path: private
          method: get
          private: true  # API KeyÂøÖÈ†à
```

---

## Ë™çË®º„ÉªË™çÂèØ

### JWTË™çË®ºÔºàHTTP APIÔºâ

```yaml
# serverless.yml
provider:
  httpApi:
    authorizers:
      jwtAuthorizer:
        type: jwt
        identitySource: $request.header.Authorization
        issuerUrl: https://cognito-idp.ap-northeast-1.amazonaws.com/${self:custom.userPoolId}
        audience:
          - ${self:custom.userPoolClientId}

functions:
  protectedApi:
    handler: handler.main
    events:
      - httpApi:
          path: /protected
          method: get
          authorizer:
            name: jwtAuthorizer
```

### Lambda „Ç™„Éº„ÇΩ„É©„Ç§„Ç∂„Éº

```typescript
// src/authorizers/custom.ts
import { APIGatewayAuthorizerResult, APIGatewayTokenAuthorizerEvent } from 'aws-lambda'
import jwt from 'jsonwebtoken'

export const handler = async (
  event: APIGatewayTokenAuthorizerEvent
): Promise<APIGatewayAuthorizerResult> => {
  const token = event.authorizationToken.replace('Bearer ', '')

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET!)

    return {
      principalId: decoded.sub,
      policyDocument: {
        Version: '2012-10-17',
        Statement: [
          {
            Action: 'execute-api:Invoke',
            Effect: 'Allow',
            Resource: event.methodArn
          }
        ]
      },
      context: {
        userId: decoded.sub,
        email: decoded.email
      }
    }
  } catch (error) {
    throw new Error('Unauthorized')
  }
}
```

```yaml
# serverless.yml
functions:
  customAuthorizer:
    handler: src/authorizers/custom.handler

  protectedApi:
    handler: handler.main
    events:
      - http:
          path: protected
          method: get
          authorizer:
            name: customAuthorizer
            resultTtlInSeconds: 300
            identitySource: method.request.header.Authorization
```

### Cognito „Ç™„Éº„ÇΩ„É©„Ç§„Ç∂„Éº

```yaml
# serverless.yml
provider:
  httpApi:
    authorizers:
      cognitoAuthorizer:
        type: jwt
        identitySource: $request.header.Authorization
        issuerUrl: https://cognito-idp.${self:provider.region}.amazonaws.com/${self:custom.userPoolId}
        audience:
          - ${self:custom.userPoolClientId}

functions:
  protectedApi:
    handler: handler.main
    events:
      - httpApi:
          path: /protected
          method: get
          authorizer:
            name: cognitoAuthorizer
            scopes:
              - email
              - profile
```

### LambdaÈñ¢Êï∞ÂÜÖ„ÅßË™çË®ºÊÉÖÂ†±ÂèñÂæó

```typescript
// src/functions/protected.ts
import { APIGatewayProxyHandlerV2 } from 'aws-lambda'

export const handler: APIGatewayProxyHandlerV2 = async (event) => {
  // JWTË™çË®º„ÅÆÂ†¥Âêà
  const userId = event.requestContext.authorizer?.jwt.claims.sub
  const email = event.requestContext.authorizer?.jwt.claims.email

  // Lambda„Ç™„Éº„ÇΩ„É©„Ç§„Ç∂„Éº„ÅÆÂ†¥Âêà
  const userIdFromContext = event.requestContext.authorizer?.userId

  return {
    statusCode: 200,
    body: JSON.stringify({
      message: 'Protected resource',
      userId,
      email
    })
  }
}
```

---

## CORSË®≠ÂÆö

### HTTP API „ÅÆ CORS

```yaml
# serverless.yml
provider:
  httpApi:
    cors:
      allowedOrigins:
        - https://example.com
      allowedHeaders:
        - Content-Type
        - Authorization
        - X-Api-Key
      allowedMethods:
        - GET
        - POST
        - PUT
        - DELETE
        - OPTIONS
      allowCredentials: true
      exposedResponseHeaders:
        - X-Request-Id
      maxAge: 6000
```

### REST API „ÅÆ CORS

```yaml
# serverless.ymlÔºàÁ∞°ÊòìÁâàÔºâ
functions:
  api:
    handler: handler.main
    events:
      - http:
          path: api
          method: any
          cors: true
```

```yaml
# serverless.ymlÔºàË©≥Á¥∞ÁâàÔºâ
functions:
  api:
    handler: handler.main
    events:
      - http:
          path: api
          method: any
          cors:
            origin: 'https://example.com'
            headers:
              - Content-Type
              - Authorization
            allowCredentials: true
```

### LambdaÈñ¢Êï∞„ÅßCORSË®≠ÂÆö

```typescript
// „Éò„ÉÉ„ÉÄ„Éº„Å´ËøΩÂä†
export const handler = async (event: any) => {
  return {
    statusCode: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Content-Type,Authorization',
      'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
    },
    body: JSON.stringify({ message: 'Success' })
  }
}
```

---

## „É™„ÇØ„Ç®„Çπ„Éà/„É¨„Çπ„Éù„É≥„ÇπÂ§âÊèõ

### „É™„ÇØ„Ç®„Çπ„Éà„Éû„ÉÉ„Éî„É≥„Ç∞

```yaml
# serverless.yml
functions:
  legacy:
    handler: handler.main
    events:
      - http:
          path: legacy
          method: post
          integration: lambda
          request:
            template:
              application/json: |
                {
                  "body": $input.json('$'),
                  "method": "$context.httpMethod",
                  "headers": {
                    #foreach($header in $input.params().header.keySet())
                    "$header": "$util.escapeJavaScript($input.params().header.get($header))"
                    #if($foreach.hasNext),#end
                    #end
                  }
                }
```

### „É¨„Çπ„Éù„É≥„Çπ„Éû„ÉÉ„Éî„É≥„Ç∞

```yaml
# serverless.yml
functions:
  api:
    handler: handler.main
    events:
      - http:
          path: api
          method: get
          integration: lambda
          response:
            headers:
              Content-Type: "'application/json'"
            template: $input.path('$.body')
```

---

## „É¨„Éº„ÉàÂà∂Èôê„Å®„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞

### Usage PlansÔºàREST APIÔºâ

```yaml
# serverless.yml
provider:
  apiGateway:
    usagePlan:
      - basic:
          quota:
            limit: 1000        # ÊúàÈñì„É™„ÇØ„Ç®„Çπ„ÉàÊï∞
            period: MONTH
          throttle:
            rateLimit: 10      # ÁßíÈñì„É™„ÇØ„Ç®„Çπ„ÉàÊï∞
            burstLimit: 20     # „Éê„Éº„Çπ„Éà„É™„ÇØ„Ç®„Çπ„ÉàÊï∞
```

### „Ç¢„Ç´„Ç¶„É≥„Éà„É¨„Éô„É´„ÅÆ„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞

```bash
# AWS CLI „Åß„Ç¢„Ç´„Ç¶„É≥„ÉàË®≠ÂÆö
aws apigateway update-account \
  --patch-operations \
    op=replace,path=/throttle/rateLimit,value=1000 \
    op=replace,path=/throttle/burstLimit,value=2000
```

### „Çπ„ÉÜ„Éº„Ç∏„É¨„Éô„É´„ÅÆ„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞

```yaml
# serverless.yml
provider:
  apiGateway:
    throttle:
      rateLimit: 100
      burstLimit: 200
```

### „É°„ÇΩ„ÉÉ„Éâ„É¨„Éô„É´„ÅÆ„Çπ„É≠„ÉÉ„Éà„É™„É≥„Ç∞

```yaml
# serverless.yml
functions:
  expensiveOperation:
    handler: handler.main
    events:
      - http:
          path: expensive
          method: post
          throttle:
            rateLimit: 10
            burstLimit: 20
```

---

## „Ç´„Çπ„Çø„É†„Éâ„É°„Ç§„É≥

### Route53 + ACM + API Gateway

```yaml
# serverless.yml
plugins:
  - serverless-domain-manager

custom:
  customDomain:
    domainName: api.example.com
    basePath: ''
    stage: ${self:provider.stage}
    createRoute53Record: true
    certificateName: '*.example.com'
    endpointType: 'regional'
    securityPolicy: tls_1_2
    apiType: rest
```

```bash
# „Ç´„Çπ„Çø„É†„Éâ„É°„Ç§„É≥‰ΩúÊàê
serverless create_domain

# „Éá„Éó„É≠„Ç§
serverless deploy

# „Éâ„É°„Ç§„É≥ÂâäÈô§
serverless delete_domain
```

### „Éû„ÉÉ„Éî„É≥„Ç∞Ë®≠ÂÆö

```yaml
custom:
  customDomain:
    domainName: api.example.com
    basePath: v1         # https://api.example.com/v1/...
    stage: prod
```

---

## WebSocket API

### WebSocket API ‰ΩúÊàê

```yaml
# serverless.yml
service: websocket-api

provider:
  name: aws
  runtime: nodejs18.x
  region: ap-northeast-1

  environment:
    CONNECTIONS_TABLE: ${self:service}-${self:provider.stage}-connections

  iam:
    role:
      statements:
        - Effect: Allow
          Action:
            - dynamodb:PutItem
            - dynamodb:GetItem
            - dynamodb:DeleteItem
            - dynamodb:Scan
          Resource:
            - Fn::GetAtt: [ConnectionsTable, Arn]
        - Effect: Allow
          Action:
            - execute-api:ManageConnections
          Resource:
            - arn:aws:execute-api:*:*:**/@connections/*

functions:
  connectionHandler:
    handler: src/handlers/connection.handler
    events:
      - websocket:
          route: $connect
      - websocket:
          route: $disconnect

  defaultHandler:
    handler: src/handlers/default.handler
    events:
      - websocket:
          route: $default

  messageHandler:
    handler: src/handlers/message.handler
    events:
      - websocket:
          route: sendMessage

resources:
  Resources:
    ConnectionsTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: ${self:provider.environment.CONNECTIONS_TABLE}
        BillingMode: PAY_PER_REQUEST
        AttributeDefinitions:
          - AttributeName: connectionId
            AttributeType: S
        KeySchema:
          - AttributeName: connectionId
            KeyType: HASH
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
```

### WebSocket „Éè„É≥„Éâ„É©„ÉºÂÆüË£Ö

```typescript
// src/handlers/connection.ts
import { APIGatewayProxyHandler } from 'aws-lambda'
import { DynamoDBClient } from '@aws-sdk/client-dynamodb'
import { DynamoDBDocumentClient, PutCommand, DeleteCommand } from '@aws-sdk/lib-dynamodb'

const client = DynamoDBDocumentClient.from(new DynamoDBClient({}))
const TABLE_NAME = process.env.CONNECTIONS_TABLE!

export const handler: APIGatewayProxyHandler = async (event) => {
  const connectionId = event.requestContext.connectionId!
  const eventType = event.requestContext.eventType

  if (eventType === 'CONNECT') {
    // Êé•Á∂ö‰øùÂ≠ò
    await client.send(new PutCommand({
      TableName: TABLE_NAME,
      Item: {
        connectionId,
        connectedAt: new Date().toISOString(),
        ttl: Math.floor(Date.now() / 1000) + 86400 // 24ÊôÇÈñìÂæå„Å´ÂâäÈô§
      }
    }))

    return { statusCode: 200, body: 'Connected' }
  }

  if (eventType === 'DISCONNECT') {
    // Êé•Á∂öÂâäÈô§
    await client.send(new DeleteCommand({
      TableName: TABLE_NAME,
      Key: { connectionId }
    }))

    return { statusCode: 200, body: 'Disconnected' }
  }

  return { statusCode: 200, body: 'OK' }
}
```

```typescript
// src/handlers/message.ts
import { APIGatewayProxyHandler } from 'aws-lambda'
import { ApiGatewayManagementApiClient, PostToConnectionCommand } from '@aws-sdk/client-apigatewaymanagementapi'
import { DynamoDBDocumentClient, ScanCommand } from '@aws-sdk/lib-dynamodb'

const dynamoClient = DynamoDBDocumentClient.from(new DynamoDBClient({}))
const TABLE_NAME = process.env.CONNECTIONS_TABLE!

export const handler: APIGatewayProxyHandler = async (event) => {
  const connectionId = event.requestContext.connectionId!
  const body = JSON.parse(event.body || '{}')

  // API Gateway Management API „ÇØ„É©„Ç§„Ç¢„É≥„Éà
  const apiGatewayClient = new ApiGatewayManagementApiClient({
    endpoint: `https://${event.requestContext.domainName}/${event.requestContext.stage}`
  })

  // ÂÖ®Êé•Á∂öÂèñÂæó
  const connections = await dynamoClient.send(new ScanCommand({
    TableName: TABLE_NAME
  }))

  // ÂÖ®Êé•Á∂ö„Å´„Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„Éà
  const postCalls = connections.Items?.map(async ({ connectionId: connId }) => {
    try {
      await apiGatewayClient.send(new PostToConnectionCommand({
        ConnectionId: connId,
        Data: JSON.stringify({
          type: 'message',
          from: connectionId,
          message: body.message
        })
      }))
    } catch (error) {
      console.error(`Failed to send to ${connId}:`, error)
    }
  })

  await Promise.all(postCalls || [])

  return { statusCode: 200, body: 'Message sent' }
}
```

### WebSocket „ÇØ„É©„Ç§„Ç¢„É≥„Éà

```typescript
// „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂÅ¥
const ws = new WebSocket('wss://your-api-id.execute-api.ap-northeast-1.amazonaws.com/dev')

ws.onopen = () => {
  console.log('Connected')

  // „É°„ÉÉ„Çª„Éº„Ç∏ÈÄÅ‰ø°
  ws.send(JSON.stringify({
    action: 'sendMessage',
    message: 'Hello, WebSocket!'
  }))
}

ws.onmessage = (event) => {
  const data = JSON.parse(event.data)
  console.log('Received:', data)
}

ws.onerror = (error) => {
  console.error('WebSocket error:', error)
}

ws.onclose = () => {
  console.log('Disconnected')
}
```

---

## „É¢„Éã„Çø„É™„É≥„Ç∞

### CloudWatch „É°„Éà„É™„ÇØ„Çπ

```
‰∏ªË¶Å„É°„Éà„É™„ÇØ„Çπ:
- Count: „É™„ÇØ„Ç®„Çπ„ÉàÊï∞
- IntegrationLatency: „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâÂá¶ÁêÜÊôÇÈñì
- Latency: Á∑è„É¨„Çπ„Éù„É≥„ÇπÊôÇÈñì
- 4XXError: „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Ç®„É©„Éº
- 5XXError: „Çµ„Éº„Éê„Éº„Ç®„É©„Éº
```

### CloudWatch Logs

```yaml
# serverless.yml
provider:
  logs:
    restApi:
      accessLogging: true
      executionLogging: true
      level: INFO
      fullRequestResponse: true

  httpApi:
    accessLogging: true
```

### X-Ray „Éà„É¨„Éº„Ç∑„É≥„Ç∞

```yaml
# serverless.yml
provider:
  tracing:
    apiGateway: true
    lambda: true

functions:
  api:
    handler: handler.main
    tracing: Active
```

---

## „Éô„Çπ„Éà„Éó„É©„ÇØ„ÉÜ„Ç£„Çπ

### 1. APIË®≠Ë®à

```
‚úì RESTful „Å™ URL Ë®≠Ë®à
‚úì ÈÅ©Âàá„Å™ HTTP „É°„ÇΩ„ÉÉ„Éâ‰ΩøÁî®
‚úì „Éê„Éº„Ç∏„Éß„Éã„É≥„Ç∞Ôºà/v1/usersÔºâ
‚úì „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥ÂØæÂøú
‚úì „É¨„Çπ„Éù„É≥„ÇπÂΩ¢ÂºèÁµ±‰∏Ä
```

### 2. „Ç®„É©„Éº„Éè„É≥„Éâ„É™„É≥„Ç∞

```typescript
// Áµ±‰∏Ä„Ç®„É©„Éº„É¨„Çπ„Éù„É≥„Çπ
interface ErrorResponse {
  error: {
    code: string
    message: string
    details?: any
  }
}

export const errorResponse = (statusCode: number, code: string, message: string) => ({
  statusCode,
  headers: {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*'
  },
  body: JSON.stringify({
    error: { code, message }
  })
})

// ‰ΩøÁî®‰æã
return errorResponse(404, 'USER_NOT_FOUND', 'User not found')
return errorResponse(400, 'INVALID_REQUEST', 'Email is required')
```

### 3. „É¨„Çπ„Éù„É≥„Çπ„Ç≠„É£„ÉÉ„Ç∑„É≥„Ç∞

```yaml
# serverless.yml
functions:
  getUsers:
    handler: handler.getUsers
    events:
      - http:
          path: users
          method: get
          caching:
            enabled: true
            ttlInSeconds: 300  # 5ÂàÜÈñì„Ç≠„É£„ÉÉ„Ç∑„É•
```

### 4. „É™„ÇØ„Ç®„Çπ„Éà„Çµ„Ç§„Ç∫Âà∂Èôê

```yaml
# serverless.ymlÔºà„Éá„Éï„Ç©„É´„Éà10MBÔºâ
provider:
  apiGateway:
    minimumCompressionSize: 1024  # 1KB‰ª•‰∏ä„ÇíÂúßÁ∏Æ
```

### 5. „Çπ„ÉÜ„Éº„Ç∏Â§âÊï∞

```yaml
# serverless.yml
provider:
  stage: ${opt:stage, 'dev'}
  environment:
    LAMBDA_ENDPOINT: ${self:custom.lambdaEndpoints.${self:provider.stage}}

custom:
  lambdaEndpoints:
    dev: https://dev-api.example.com
    prod: https://api.example.com
```

### 6. API„Éâ„Ç≠„É•„É°„É≥„ÉàÁîüÊàê

```bash
# OpenAPI ‰ªïÊßòÊõ∏„Ç®„ÇØ„Çπ„Éù„Éº„Éà
aws apigateway get-export \
  --rest-api-id your-api-id \
  --stage-name prod \
  --export-type swagger \
  --accepts application/json \
  output.json
```

---

## ÂèÇËÄÉ„É™„É≥„ÇØ

- [AWS API Gateway Documentation](https://docs.aws.amazon.com/apigateway/)
- [HTTP APIs vs REST APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html)
- [WebSocket APIs](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html)
